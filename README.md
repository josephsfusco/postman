# Overview
The purpose of this project is to create a simple HTTP Server which which has two services
* Authentication Service

* Business Service 

The two servcies are "seperate" and work in unison to authenticate a user with basic auth, provide a Bearer Token and subsequently request data using the current and valid token. 

Basic auth is maintained by a simple in memory database with usernames (emails) and passwords encrypted using a simple hash. 

Tokens are generated by Auth Server and stored in memory upon sucessful display of basic credentials. To maintain security tokens are only valid for thirty (30) seconds. 

To requests data Client must include the Bearer Token in the request headers, to verify authenticity Business Service then makes a follow-up outbound request to Auth Service to validate the token. This ensures a seperation of duty and allowed Business Service the liberty to have no knowledge of what keys are valid or not.


# Getting Started
**Running Locally**

Unpack the Docker docker compose file and run the following commands. ensure that you are in the `/postman` directory
```
$ pwd
> /postman

$ ./startServer
> Serving Flask app 'server'
> Running on http://x.x.x.x:xxxx
```

**Running Remotely**

This project is deployed on Heroku at the following domain {domain} 

**Using the App**

1. Start by requesting a bearer token. Make a [`POST`] request to `/login` using the below user name and password. Find the request format documented below in the `Endpoints` section
   
> `username: jsf.fusco@gmail.com`
>
> `password: postman`

2. Follow by requesting data. Make a [`GET`] request to `/data` include the bearer token generated in step (1) Find the request format documented below in the `Endpoints` section


# Endpoints
### **Public**

  ``` 
  /login
     Body: { 'username' : <username>,
             'password' : <password>
     }
  
     Response: {'token' : <bearer token>}
  ```
  
  ```
  /data
      Headers: {'token' : <bearer token>}
      
      Response: {'data' : <data>}
  ```

### **Internal**
```
/validateToken
    Body: {'token' : <bearer token>}

    Response: {'authenticated' : <bool>}
```

# Authentication
### **Basic Authentication**
We use a simple in memeory data base which contains usernames and passwords. passwords are encrpyted using a simple hash 

### **Token Authentication**
A token is generated upon providing sucessful proof of basic auth which is then stored in memory. The tokens contain timestamp information and are only valid for 30 seconds from the time of distribution. 

> **Notes to reviewers:** This is a *very* primitive way of hashing for encrptyon and generating a time stamped token. This level of simplysity is only used because this is a proof of concept. 

# Memory Management
A new token is created each time a user requests one using `/login` as the token is stored in memeory this being left unmanaged will cause memory bloat. It is therefore impatative that we have a medium of removing stale tokens from memory. 

I considered two different approaches to doing this. 

First, `/login` is the sole culprate of creating and caching new tokens it is therefore obvious to leverage this endpoint as a mechanism to trigger cleanup

Second, `Background Cleanup` create a scheduled job which runs in background to clean up all stale tokens. 

While I considered both options I decided to use the second approach as it seperates delegation of work. 

# Flow
1) Client initiates by making call to Auth Server authenticating using the provided given username and password.
2) If basic creds are valid Auth Server generates a Bearer Token and responds with it to Client.
3) Client makes a subsequent call to Business Server including the Bearer Token in the request headers.
4) Business Server makes an internal call to Auth Server to verify the Token.
5) Auth Server returns the Authenticity of the Token
6) If valid Business Server responds with Data

![](/images/FlowChart.png)

# Testing
### **Unit Testing**
Basic unit test coverage provdied. For a given function we are ensuring positive and negative test cases exist. 
```
$ pwd
> /postman

$ ./runTests
> testing output
```
> Note: We are not testing 100% for the purpose of this exercise but would ensure we have complete coverage for production level code.

### **System Testing**
State diagram provided for testing 

- [ ] All paths tested and succeded 
  
![](/images/StateDiagram.png)

# TODO

- [X] fix cleanup job 

- [X] optomise hashing  (?)

- [X] return 401s from public servides

- [X] check status codes on auth response 
- [X] finish function documentation
- [ ] logging
- [ ] unit testing   
- [X] finish overview documentation
- [ ] finish getting started doc 