# Overview
The purpose of this project is to create a simple HTTP Server which which has two services
* Authentication Service

* Business Service 

The two servcies are "seperate" and work in unison to authenticate a user with basic auth, provide a Bearer Token and subsequently request data using the current and valid token. 

Basic auth is maintained by a simple in memory database with usernames (emails) and passwords encrypted using a simple hash. 

Tokens are generated by and stored on the Auth Server in memory upon successfully providing basic credentials. To maintain security tokens are only valid for thirty (30) seconds. 

When Client requests data, Business Service makes a follow-up request to Auth Service, this ensures a seperation of services. Business Service has no knowledge of what keys are valid or not.


# Getting Started
This project is deployed on Heroku at the following domain {domain}
to begin make a [GET] request to the following endpoint 
`/basicAuthentication` using the below user name and password 

> `username: jsf.fusco@gmail.com`
>
> `password: postman`





# Endpoints
### **Public**

  ``` 
  /basicAuthentication
     Request body: { 'username' : <username>,
                     'password' : <password>
     }
  
     Response: {'token' : <bearer token>}
  ```
  
  ```
  /data
      headers: {'token' : <bearer token>}
      
      Response: {'data' : <data>}
  ```

### **Internal**
```
/TokenAuthentication
    Request body: {'token' : <bearer token>}

    Response: {'authenticated' : <Bool>}
```

# Authentication
### **Basic Authentication**
We use a simple in memeory data base which contains usernames and passwords. passwords are encrpyted using a simple hash 

### **Token Authentication**
A token is generated upon providing sucessful proof of basic auth which is then stored in memory. The tokens contain timestamp information and are only valid for 30 seconds from the time of distribution. 

> **Notes to reviewers:** This is a *very* primitive way of hashing for encrptyon and generating a time stamped token. This level of simplysity is only used because this is a proof of concept. 

# Memory Management
A new token is created each time a user requests one using `/basicAuthentication` as the token is stored in memeory this being left unmanaged will cause memory bloat. It is therefore impatative that we have a medium of removing stale tokens from memory. 

I considered two different approaches to doing this. 

First, `/basicAuthentication` is the sole culprate of creating and caching new tokens it is therefore obvious to leverage this endpoint as a mechanism to trigger cleanup

Second, `Background Cleanup` create a scheduled job which runs in background to clean up all stale tokens. 

While I considered both options I decided to use the second approach as it seperates delegation of work. 

# Flow
1) Client initiates by making call to Auth Server authenticating using the provided given username and password.
2) If basic creds are valid Auth Server generates a Bearer Token and responds with it to Client.
3) Client makes a subsequent call to Business Server including the Bearer Token in the request headers.
4) Business Server makes an internal call to Auth Server to verify the Token.
5) Auth Server returns the Authenticity of the Token
6) If valid Business Server responds with Data

![](/images/FlowChart.png)

# Testing
### **Unit Testing**
Basic unit test coverage provdied. Would ensure 100% testing for production

### **System Testing**
State diagram provided for testing 

- [ ] All paths tested and succeded 
  
![](/images/StateDiagram.png)

# TODO

- [ ] fix cleanup job 

- [X] optomise hashing  (?)

- [X] return 401s from public servides

- [X] check status codes on auth response 
- [ ] finish function documentation
- [ ] logging
- [ ] unittesting   
- [ ] finish overview documentation
