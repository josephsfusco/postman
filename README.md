# Overview
The purpose of this project is to create a simple HTTP Server which which has two services
* Authentication Service

* Business Service 

The two servcies are "seperate" and work in independently to authenticate a user logging in with basic credentials, provide them with a bearer token for their session, and subsequently allow them access to the business server for the remaineder of their session. 

Basic auth is maintained by a simple in memory database with usernames (emails) and passwords encrypted using a simple hash. 

Tokens are generated by Auth Server when a users logs in with proof of basic credentials. The token is created, stored in memeory along with a TTL of thiery (30) second.

> **Note to reviewers:** thirty seconds is extremely low and is configured as such for demo purposes. 

The Client will then include the token as a header in all subsequent requests to the Business service verifing authenticity of the user for the session. 
To requests data Client must include the Bearer Token in the request headers, to verify authenticity Business Service then makes a follow-up outbound request to Auth Service to validate the token. This ensures a seperation of duty and allowed Business Service the liberty to have no knowledge of what keys are valid or not.


# Getting Started
**Running Remotely**

This project is deployed on Heroku at the following domain {domain} 

> Note to reviewers: The server may be asleep and take a few moments to wake up for the first request. 

**Running Locally**

Docker up the docker compose file and run the following commands. ensure that you are in the `/postman` directory
```
$ pwd
> /postman

$ ./startServer
> Serving Flask app 'server'
> Running on http://x.x.x.x:xxxx
```

**Using the App** 

1. Using the Postman App, start by requesting a bearer token. Make a [`POST`] request to `/login` using the below user name and password. Find the request format documented below in the `Endpoints` section
   
> `username: jsf.fusco@gmail.com`
>
> `password: postman`

2. Follow by requesting data. Make a [`GET`] request to `/data` include the bearer token generated in step (1) in the headers. Find the request format documented below in the `Endpoints` section

> Bonus: setting up a Postman Flow works very well for this. 


# Endpoints
### **Public**

  ``` 
  /login
     Body: { 'username' : <username>,
             'password' : <password>
     }
  
     Response: {'token' : <bearer token>}
  ```
  
  ```
  /data
      Headers: {'token' : <bearer token>}
      
      Response: {'data' : <data>}
  ```

### **Internal**
```
/validateToken
    Body: {'token' : <bearer token>}

    Response: {'authenticated' : <bool>}
```

# Authentication
### **Basic Authentication**
We use a simple in memeory data base which stores usernames and encrypted passwords. In order to maintain a basic level of security passwords are encrpyted using a very simple one way hash. When we, the server, rerecieve a login request we hash the value of the user provided password and verify it matches that of the hash in the database, crucially this means we never decrpt the known password. 

### **Bearer Token Authentication**
First, What is a bearer token? A Bearer Token is a simple token which provides the bearer of the token access to anything secured by the token. These tokens often come in a few different flavors, reinflating, fixed Time to Live (TTL), and single use. In practice for client to server communication reinflating tokens are the most common which is what we've decdied to do here. By comparison fixed ttl are frequently used for server to server communication and single use are used for account creation verification. 

Its important to note that bearer tokens are only secure over HTTPS and not HTTP as the packaged can be sniffed and the contents including the token can be compromised by an attacker. 

> **Note to reviewers:** For simplicity across local and remote deploys we are in fact using HTTP here but we would not if deploying to anything but a dev environment. 

Next, Lets dive into our implmentation of them. Upon providing sucessful proof of basic auth our application creates a token object initializing it with some basic infrmation; Time to Live (TTL), original creation moment, and refresh count. When Client makes a request to `/data` the token must be included in the headers. The Business Server begins by making an internal call out to the Auth Server with the token requesting its authenticity. If valid the Auth Server reinflates the token giving it another thirty (30) to live and returns its authenticity status to the calling service, in this case Business Service. 


# Memory Management
A new token is created each time a user requests one using `/login` as the token is stored in memeory this being left unmanaged will cause memory bloat. It is therefore impatative that we have a medium of removing stale tokens from memory. 

we can considered two different approaches to handle this.

First, lets look at the source of the issue, `/login` is the sole culprate of creating and caching new tokens it is therefore obvious to leverage the invocation of this endpoint as a mechanism to trigger cleanup. The obvious drawback to this would be user experience. Imagine a user having to wait for a background cleanup job to finish just to log in. 

Second, lets look at an option that doesnt impact the user experience, `Background Cleanup` supose create a backgrounc clean up job which runs at scheduled intervals to manage dead tokens. 

While we can consider both options and at our current size we will perhaps see minimal difference with either solution, we may want to approach this problem with some foresight as to our our application may scale. As we grow managing tokens will turn into a larger issue and decoupling it from our login service may be adventagous. furthermore we should look even further down the line and consider what 3rd party services are available for us to leverage and design our archtecutre in a modular way where we can plug and play a new tool in. It is for this reason that we pick the second approach. See `Future Improvements, Scalability & System Design Considerations` for more on scaling.

# Flow
1) Client initiates by making call to Auth Server authenticating using the provided given username and password.
2) If basic creds are valid Auth Server generates a Bearer Token and responds with it to Client.
3) Client makes a subsequent call to Business Server including the Bearer Token in the request headers.
4) Business Server makes an internal call to Auth Server to verify the Token.
5) Auth Server returns the Authenticity of the Token and reinflates the token if valid
6) If valid Business Server responds with Data

![](/images/FlowChart.png)

# Logging

We've included a very basic logging framework. This could easily be extended to have log levels and implement a more extensive logging library. 

# Testing
### **Unit Testing**
Basic unit test coverage provdied. For a given function we are ensuring positive and negative test cases exist. 
```
$ pwd
> /postman

$ ./runTests
> testing output
```
> Note: We are not testing 100% for the purpose of this exercise but would ensure we have complete coverage for production level code.

### **End to End Testing**
State diagram shows all testing flows 

- [ ] All paths tested and succeded 
  
![](/images/StateDiagram.png)

# Future Improvements, Scalability & System Design Considerations
### Database and Memory Managment 
First lets quickly look at the users 'database', in my opinion the obvious choice would be a relational database here, as we are storing inherently relational data. We would expand our basic key value pair into a class that would contain store basic user information (eg: ID, email, etc) and relational references to other information we may want to track.

Since we've primaryly focused on building an authentication service, lets explore its scalability. While the size of each token is very small, lets assume 100bytes, this means storing 1M tokens would result in ~100mb of data in memeory, any modern device could handle this. So if data isnt our scaling problem, what is? Accessing and maintaining the data would quickly become our issue with 1M tokens we need a highly available fast lookup service to manage our tokens. As we said before we want to modularize our application so this component can be scaled but what if we could use a service for this? **Redis** is a great example of a service which we could leverage here, with its high availability and in memory data structures, this is a great candidate of a product that meets our requirements and would help offload some of the work.

Now lets look at our throughput. Where are we deployed? currently were on heroku which handles 4500call/hr (75tpm) this is great if were trying to create a POC that will help get us off the ground but we'll soon outgrow this once we get a few dozen active users. To make our service highly available we'll need to use an elastic service like AWS ECS/EC2 which will be able to scale up to 100+tps. 
